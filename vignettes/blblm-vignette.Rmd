---
title: "The blblm Package"
author: "Aravind Krishnachandran"
date: "6/10/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{blblm-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(blblm)
library(nycflights13)
```

The blblm package allows a user to use the bag of little bootstraps algorithm to calculate coefficients of linear models, along with the standard errors of those coefficents. The package also allows the user to utilize parallelization, allowing tasks to be increased in speed and reduce memory usage. 

## Parallelization

The `parallelization` function gives the user the choice if he/she would like to use parallelization in the blblm calculations. The function takes in two arguments. The first argument is FALSE if the user would not like to use parallelization, and TRUE if the user would like to use parallelization.The default value of this argument is FALSE. The second argument is the number of workers the user would like to distribute the tasks of the blblm calculations to. The user may first want to run `detectCores` to see how many CPUs are available to use to distribute the tasks.If the user inputs TRUE for parallel and specifies a number for the workers, then parallelization will be enabled. The function will return TRUE if the input is TRUE, indicating that parallelization has been enabled. Otherwise, it will return FALSE. This function should be run first if the user would like parallelization.

```{r}
parallelization(parallel = TRUE, workers = 2)
```

## The blblm function

The `blblm` function takes into account three cases. It has five arguments. The first is the formula for the linear model one would like to fit. The second is the data, which can be inputted either as a character vector of files or a complete data frame. The third is whether or not the user would like to use parallel. If he/she does, then he/she should have gotten the TRUE output from the parallelization method, and can use that result for this argument. The fourth is m, which denotes the number of subsamples to perform bag of little bootstraps. The fifth is B, which denotes the number of bootstraps to be performed for each subsample.

The first case is for the user to specify that he or she would like to use parallelization and the user inputted a character vector of files containing part of the data. In this case, the total number of lines is calculated using the `vroom_lines` function. This function is efficient because it does not require reading each file in the main process to determine the total number of rows. Once the total number of data rows is determined, `future_map` is utilized to apply the `lm_each_subsample` function to each file of data in the workers. The `lm_each_subsample` function uses several subfunctions to calculate the regression coefficient estimates and residual standard error estimates. These estimates are generated by performing bootstrap within each subsample and running a linear regression model with frequencies as weights for each bootstrapped sample. The file is read in the workers using `vroom`, which is faster in performance than `read_csv`. Lastly the list of estimates and sigma values, along with the model formula, are assigned to res, which is given the S3 class "blblm". The ability to ditribute files to the workers to have them read there instead of reading the whole dataset in the main process helps minimize memory usage.

```{r}
#dir.create("files", showWarnings = FALSE)
#set.seed(141)
#1:100 %>% walk(function(i) {
#    dt <- tibble(x = rnorm(5000), y = rnorm(5000))
#    write_csv(dt, file.path("files", sprintf("file%02d.csv", i)))
#})
#file_names <- file.path("files", list.files("files"))
#fit <- blblm(y ~ x, data = file_names, parallel = TRUE, B = 100)
#coef(fit)
```

The second case is when the user decides he/she would like to use parallelization but does not pass a vector of files. Instead he/she passes in the entire dataset. The dataset is split into m sections, and then `future_map` applies the `lm_each_subsample` to each data split within the workers. This option is faster in performance than not using parallelization.

```{r}
fit <- blblm(dep_time ~ arr_delay, data = flights, parallel = TRUE, m = 10, B = 100)
coef(fit)
```

If the user specifies that he/she does not want to use parallelization, then the data is loaded in the main process. The data is then split into the m specified subsamples by using the `split_data` function. Then the `map` function is used to apply the `lm_each_subsample` function to each subsample of data contained in data_list. The result is a list of lists. The first set of lists contain the estimates, while the second set contains the formula. For each subsample there are B Bootstrap estimates of the coefficients and sigma.

```{r}
fit <- blblm(mpg ~ wt * hp, data = mtcars, parallel = FALSE, m = 3, B = 100)
coef(fit)
```


## The print method

`print.blblm` is a S3 class method for blblm. It prints out the formula inputted into blblm function to be fitted.

```{r}
fit <- blblm(dep_time ~ arr_delay, data = flights, parallel = FALSE, m = 10, B = 100)
print(fit)
```

## The sigma method

`sigma.blblm` is a S3 class method for blblm which calculates the estimated sigma value, which is the residual standard error for a linear regression model. The first argument for this method is the fitted blblm model. The user can specify whether or not he/she would like a confidence interval for this estimate of sigma by inputting confidence = TRUE, along with the level of confidence. The method first extracts all the estimates from `object` which is the fitted blblm model. It then calculates the average of all the bootstrapped sigma estimates from each subsample, and takes the mean of the averages for each subsample using `mean` and `map_dbl`. If the user specified a confidence interval, then the method will take the averages for the bounds of the interval, calculated using the `quantile` function.

```{r}
fit <- blblm(mpg ~ wt * hp, data = mtcars, parallel = FALSE, m = 3, B = 100) 
sigma(fit, confidence = TRUE, level = 0.95)
```

## The coef method

`coef.blblm` is a S3 class method for blblm which calculates the averages of the subsample means of the bootstrapped coefficient estimates. It extracts the estimates from the fitted blblm model and combines the bootstrapped estimates into a tibble. From there, the row means are taken, followed by the mean for each subsample.

```{r}
fit <- blblm(arr_delay ~ dep_time * air_time, data = flights,
               parallel = TRUE, m = 20, B = 100)
coef(fit)
```

## The confint method

`confint.blblm` is a S3 class method for blblm which constructs confidence intervals for named coefficients in the model (non-intercept). If coefficient names are not specified, then confidence intervals are constructed for all coefficient names, including interaction terms. It extracts the estimates from the fitted blblm model. It then gathers into a matrix form the averaged interval bounds for each estimate within each subsample, with the coefficents names as the rows and the interval bounds as the columns.

```{r}
fit <- blblm(arr_delay ~ dep_time * air_time, data = flights,
               parallel = TRUE, m = 10, B = 100)
confint(fit, c("dep_time", "air_time", "dep_time:air_time"))
```

## The predict method

`predict.blblm` is a S3 class method for blblm which allows the user to predict the value of the response variable based on new observations from the predictors. It utilizes the model formula specified in blblm. If the user specifies confidence = TRUE, then the method will also output a confidence interval for the predicted estimate. The method extracts the estimates from the fitted blblm model and constructs a design matrix based on the predictor variables of the new data. In the old implementation of the blblm package, prediction resulted in an error when Y was regressed on all of the predictors (Y ~ .), with the error citing that there is no 'data' argument. This error was fixed by changing `X <- model.matrix(reformulate(attr(terms(object$formula), "term.labels")), new_data)` to `X <- model.matrix(reformulate(attr(terms.formula(object$formula,data = new_data), "term.labels")), new_data)`. The design matrix is multiplied with the estimates of the coefficients. They are combined into a tibble to find their means, and the confidence interval is calculated.

```{r}
fit <- blblm(mpg ~ wt * hp, data = mtcars, parallel = TRUE, m = 3, B = 100)
predict(fit, data.frame(wt = c(7, 5.5), hp = c(130, 190)), confidence = TRUE, level = 0.95)
```